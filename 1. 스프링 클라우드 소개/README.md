# 마이크로 서비스 아키텍쳐로 진화

## N-계층 아키텍쳐

> 일반적인 엔터프라이즈 아키텍쳐 유형 중 하나는 다계층 또는 N-계층 아키텍쳐다. 이 디자인에서 애플리케이션은 UI, 서비스, 데이터, 테스팅 등 고유의 책임과 기능이 있는 여러 계층으로 나뉜다. 예를 들어 애플리케이션을 만들 때는 UI(사용자 인터페이스)를 위한 특정 프로젝트나 솔류션을 만든 후 서비스를 위한 프로젝트나 솔류션을 만들고 데이터에 대한 것을 만든다. 결국 전체 애플리케이션을 만드는 여러 프로젝트가 결합되고 만다. 

- 장점 
    - N-계층 애플리케이션에서는 관심사가 잘 분리되어 있어 UI, 데이터, 비지니스 로직 같은 영역을 따로 고려할 수 있다.
    - 팀이 N-계층 애플리케이션의 여러 컴포넌트에서 독립적으로 작업하기 쉽다
    - 널리 알려진 엔터프라이즈 아키텍쳐이므로 숙련된 N-계층 프로젝트 개발자를 찾기가 상대적으로 수월하다.

- 단점 
    - 변경을 적용하려면 전체 애플리케이션을 중지하고 재시작해야 한다.
    - 메시지가 상하 전체 계층에 통행하므로 비효율적일 수 있다.
    - 대규모 N-계층 애플리케이션이 배포되고 나면 리팩터링은 어려울 수 있다.

## 모놀리스 아키텍쳐

- 중소 규모의 많은 웹 애플리케이션은 모놀리스 아키텍쳐 형태로 구축된다. 모놀리스 아키텍쳐에서 애플리케이션은 배포 가능한 하나의 산출물로 생성된다. 모든 UI, 비지니스 및 데이터베이스 액세스 로직은 함께 고유한 애플리케이션으로 패키징되어 애플리케이션 서버에 배포된다.  

![image1](https://raw.githubusercontent.com/yonggyo1125/lecture_springcloud/master/1.%20%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%20%EC%86%8C%EA%B0%9C/images/1.png)

- 모놀리스 애플리케이션에서 모든 코드가 단일 유닛으로 빌드, 테스트, 배포되어야 하기 떄문에 여러 개발팀은 배포일을 맞추어야 한다.

- 애플리케이션은 단일 작업 단위로 배포될 수 있지만 한 애플리케이션에서 여러 개발 팀이 작업하는 경우가 많다. 각 개발 팀은 일반적으로 특정 고객을 대상으로 하는 애플리케이션의 개별 부분을 담당한다. 예를 들어 UI/UX, 고객, 데이터 웨어하우스, 금융 관계자 등을 포함한 여러 팀과 조율해야 하는 사내 맞춤형 고객 관계 관리(CRM) 애플리케이션의 시나리오를 생각해 보자
- 마이크로 서비스 아키텍쳐 옹호론자들은 때때로 모놀리스 애플리케이션을 부정적으로 설명하기도 하지만 모놀리스는 종종 휼륭한 선택지다. 모놀리스는 N-계층 또는 마이크로서비스 같은 복잡한 아키텍처보다 구축 및 배포가 더 쉽다. 사용 사례가 잘 정의되어 있고 변경 가능성이 낮다면 모놀리스로 시작하는 것이 좋다.
- 애플리케이션의 크기와 복잡성이 증가하기 시작하면 모놀리스를 관리하는 것은 어려운 일이 될 수 있다. 모놀리스에 대한 모든 변경이 애플리케이션의 다른 부분까지 차례로 영향을 줄 수 있고, 이 때문에 운영 환경의 시스템에서는 더 많은 시간과 비용이 소요될 것이다. 이에 반해 세번쨰 옵션인 마이크로 서비스 아키텍처는 유연함과 유지 보수의 이점을 더 많이 제공할 수 있다. 

## 마이크로서비스란? 

> 마이크로서비스 개념은 대규모 모놀리스 애플리케이션을 기술적 또는 조직적으로 확장하는 데 직면한 많은 난제에 대한 직접적인 대응으로 소프트웨어 개발 커뮤니티에서 태동했다. 마이크로서비스는 작고 느슨하게 결합된 분산 서비스이다. 마이크로 서비스를 사용하면 대규모 애플리케이션을 책임이 명확하고 관리하기 쉬운 구성 요소로 분해할 수 있다. 또한 잘 정의된 작은 조각으로 분해해서 대규모 코드베이스에서 발생하는 전통적인 복잡성 문제를 해결하도록 도울 수 있다. 

- 마이크로서비스를 고려할 떄 이해해야 할 핵심 개념은 분해(decomposing)과 분리(unbunding)다. 애플리케이션의 기능은 완전히 상호 독립적이어야 한다. 앞서 언급한 CRM 애플리케이션을 마이크로서비스로 분해하면 다음과 같을 것이다.

![image1](https://raw.githubusercontent.com/yonggyo1125/lecture_springcloud/master/1.%20%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%20%EC%86%8C%EA%B0%9C/images/2.png)

> 마이크로서비스를 사용하면 CRM 애플리케이션이 완전히 상호 독립적인 마이크로서비스로 분해됨으로써 각 개발 팀이 제 속도를 유지할 수 있다.

- 마이크로서비스 아키텍처의 특징
  - 애플리케이션 로직은 명확하고 대등한 책임 경계가 있는 작은 컴포넌트로 분해된다.
  - 각 구성 요소는 작은 책임 영역을 담당하고 서로 독립적으로 배포된다. 한 마이크로서비스는 비즈니스 도메인을 한 부분에 책임을 진다. 
  - 마이크로서비스는 서비스 소비자와 공급자 간 데이터를 교환하고자 HTTP와 JSON(JavaScript Object Notation) 같은 경량의 통신 프로토콜을 사용한다. 
  - 마이크로서비스 애플리케이션은 항상 기술 중립적 포맷(대표적으로 JSON)을 사용해서 통신하기 때문에 서비스 하부의 기술 구현과 무관하다. 이 말은 마이크로서비스 방식으로 구축된 애플리케이션은 다양한 언어와 기술로 구현될 수 있다는 의미다. 
  - 작고 독립적이고 분산적인 마이크로서비스 특성 덕분에 조직은 팀을 더 작게 만들고 명확한 책임 영역을 부여할 수 있다. 이들 팀은 애플리케이션 출시처럼 하나의 목표를 향해 일하더라도 그들이 작업하는 서비스에만 책임을 진다.
  
### 모놀리식과 마이크로서비스 아키텍처 비교

![image1](https://raw.githubusercontent.com/yonggyo1125/lecture_springcloud/master/1.%20%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%20%EC%86%8C%EA%B0%9C/images/3.png)


## 애플리케이션 구축 방법을 왜 바꾸어야 할까?

> 국내 시장에서 일해 온 기업들은 글로벌 고객에게 진출할 수 있다는 사실을 빠르게 깨닫고 있다. 하지만 글로벌 고객이 늘어날수록 글로벌 경쟁 또한 치열해진다. 더 많은 경쟁으로 인해 애플리케이션인 구축에 대한 개발자들의 사고방식은 다음과 같이 영향을 받았다.

- **복잡성이 증가했다**: 고객은 기업 조직의 전 영역에서 자신이 누구인지 인식될 것을 기대한다. 또한 이제는 한 데이터베이스와 통신하고 다른 애플리케이션과 통합되지 않는 단절된(siloed) 애플리케이션은 더 이상 표준이 아니다. 오늘날 애플리케이션은 사내 데이터 센터뿐 아니라 외부 인터넷 서비스 제공자에 있는 다양한 서비스와 데이터베이스 통신을 해야 한다.
  고객은 더 빠른 전달을 원한다: 고객은 더 이상 소프트웨어 패키지 릴리스를 다음 해까지 기다리길 원치 않는다. 그 대신 소프트웨어 제품 기능을 분리해서 제공하여 새로운 기능이 몇 주 (심지어 며칠) 내 릴리스되길 기대한다.
- **고객 또한 안정적인 성능과 확장성을 요구한다**: 글로벌 애플리케이션은 언제, 얼마나 많은 트랜잭션양을 처리해야 하는지 예측하기 매우 어렵다. 애플리케이션은 트랜잭션양에 따라 많은 서버를 신속하고 매끄럽게 확장하고 축소해야 한다.

- **고객은 애플리케이션을 언제든 사용할 수 있길 기대한다**: 고객은 경쟁사와 한 클릭 차이 정도로 경쟁하므로 애플리케이션은 회복성(resiliency)이 높아야 한다. 애플리케이션 한 부분의 고장이나 문제가 전체 애플리케이션으로 확대되지 않아야 한다.

> 이러한 기대를 충족하기 위해 애플리케이션 개발자인 우리는 확장성과 중복성이 높은 애플리케이션을 구축하려면 애플리케이션을 독립적으로 빌드하고 배포할 수 있는 작은 서비스로 분해해야 하는 상황을 수용해야 한다. 애플리케이션을 더 작은 서비스로 분리(unbundle)하고 단일 모놀리식 산출물에서 서비스 산출물을 추출하면 우리는 다음 시스템을 구축할 수 있다.

- **유연성(flexible)**: 분리된 서비스는 새로운 기능을 신속하게 제공하도록 구성하고 재배치 가능하다. 다른 것과 함께 작동하는 코드가 적을수록 코드 변경에 따른 복잡성도 낮아지고 코드의 테스트 및 배포 시간도 줄어든다.
- **회복성(resilient)**: 분리된 서비스란 애플리케이션이 더 이상 한 부분의 저하(degradation)로 전체가 고장 나는 진흙덩이(ball of mud) 애플리케이션이 아님을 의미한다. 고장은 애플리케이션 일부분에 국한되어 애플리케이션의 전체 장애로 확대되기 전에 억제된다. 회복성은 회복 불능의 에러인 경우에도 애플리케이션이 원만하게 저하되도록 한다.
- **확장성(scalable)**: 분리된 서비스는 여러 서버에 쉽게 수평 분산이 가능하므로 기능과 서비스를 적절히 확장하게 해 준다. 모놀리식 애플리케이션은 모든 로직이 뒤얽혀 있어 애플리케이션 일부분만 병목 현상이 발생해도 전체 애플리케이션을 축소해야 한다. 작은 서비스를 사용하면 국지적으로 확장 가능하고 비용 효율도 훨씬 높다.

> 작고(small), 단순하고(simple), 분리된(decoupled) 서비스 = 확장 가능하고(scalable), 회복적이며(resilient) 유연한(flexible) 애플리케이션