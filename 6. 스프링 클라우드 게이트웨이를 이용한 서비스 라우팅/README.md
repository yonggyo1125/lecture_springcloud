# 스프링 클라우드 게이트웨이를 이용한 서비스 라우팅
- 마이크로서비스와 같은 분산형 아키텍처에서는 보안과 로깅, 여러 서비스 호출에 걸친 사용자 추적처럼 중요한 작업을 해야 할 시점이 온다. 이 기능을 구현하려고 모든 개발 팀이 독자적인 솔루션을 구축할 필요 없이 이러한 특성을 모든 서비스에 일관되게 적용하길 원할 것이다. 공통 라이브러리나 프레임워크를 사용해서 이들 기능을 각 서비스에 직접 구축할 수도 있지만, 이 방법은 다음과 같은 결과를 초래할 수 있다.
    - **이러한 기능을 각 서비스에 일관되게 구현하기 어렵다**: 개발자는 제품 기능을 제공하는 데 매달리고 정신없이 바쁜 일상에 쫓겨 서비스 로깅이나 추적 기능이 요구되는 규제 산업에서 일하지 않는다면 이러한 기능 구현을 잊어버리기 쉽다.
    - **보안과 로깅 같은 횡단 관심사(cross-cutting concerns)의 구현 책임을 개별 개발 팀에 전가하면 잘못 구현하거나 아예 누락할 수 있다**: 횡단 관심사는 애플리케이션 전체에 적용할 수 있고, 애플리케이션의 다른 부분에 영향을 줄 수 있는 프로그램 설계 일부나 기능을 나타낸다.
    - **모든 서비스에 걸쳐 강한 의존성을 만들 수 있다**: 모든 서비스에 공유되는 공통 프레임워크에 더 많은 기능을 추가할수록 서비스 재컴파일과 재배포 없이 공통 코드의 동작 변경이나 추가는 더욱 어려워진다. 갑작스런 공유 라이브러리에 내장된 핵심 기능 업그레이드는 장기적인 이전 작업이 된다.
- 이 문제를 해결하려면 **횡단 관심사를 독립적으로 배치할 수 있고, 아키텍처의 모든 마이크로서비스 호출에 대한 필터와 라우터 역할을 할 수 있는 서비스로 추상화**해야 한다. 이러한 서비스를 <code>게이트웨이(gateway)</code>라고 한다. 서비스 클라이언트는 더 이상 마이크로서비스를 직접 호출하지 않는다. 그 대신 모든 호출은 단일 정책 시행 지점(PEP, Policy Enforcement Point) 역할을 하는 서비스 게이트웨이를 경유한 다음 최종 목적지로 라우팅된다.
- 구체적으로 살펴볼 스프링 클라우드 게이트웨이 사용 방법은 다음과 같다.
    - 하나의 URL 뒤에 모든 서비스를 배치하고 서비스 디스커버리(service discovery)를 사용하여 해당 호출을 실제 서비스 인스턴스에 매핑하는 방법
    - 서비스 게이트웨이를 경유하는 모든 서비스 호출에 상관관계 ID를 삽입하는 방법
    - HTTP 응답에 전달받은 상관관계 ID를 삽입하여 클라이언트로 재전송하는 방법

## 서비스 게이트웨이란?
- 지금까지 이전 장에서 구축한 마이크로서비스를 사용하여 웹 클라이언트로 개별 서비스를 직접 호출하거나 유레카 등 서비스 디스커버리 엔진을 사용하여 프로그램 방식으로 호출했다.

![image1](https://raw.githubusercontent.com/yonggyo1125/lecture_springcloud/master/6.%20%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%20%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EC%84%9C%EB%B9%84%EC%8A%A4%20%EB%9D%BC%EC%9A%B0%ED%8C%85/images/1.png)
> 서비스 게이트웨이가 없다면 서비스 클라이언트는 각 서비스의 엔드포인트를 직접 호출한다.

- 서비스 게이트웨이는 서비스 클라이언트와 호출되는 서비스 사이에서 중개 역할을 하고, 서비스 게이트웨이가 관리하는 하나의 URL로 통신한다. 또한 서비스 클라이언트 호출에서 보낸 경로를 분해하고 서비스 클라이언트가 호출하려는 서비스를 결정한다.
- 다음 그림은교통 정리를 하는 교통 경찰처럼 서비스 게이트웨이가 사용자를 대상 마이크로서비스와 해당 인스턴스까지 안내하는 방법을 보여 준다.

![image2](https://raw.githubusercontent.com/yonggyo1125/lecture_springcloud/master/6.%20%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%20%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EC%84%9C%EB%B9%84%EC%8A%A4%20%EB%9D%BC%EC%9A%B0%ED%8C%85/images/2.png)
> 서비스 게이트웨이는 서비스 클라이언트와 해당 서비스 인스턴스 사이에 위치하고, 모든 서비스 호출(내,외부 호출 모두)은 서비스 게이트웨이를 통과한다.

- 서비스 게이트웨이는 애플리케이션 내 마이크로서비스를 호출하기 위해 유입되는 모든 트래픽의 게이트키퍼(gatekeeper) 역할을 한다. 서비스 게이트웨이가 있으면 서비스 클라이언트는 각 서비스 URL을 직접 호출하지 않고 서비스 게이트웨이에 호출을 보낸다.
- 또한 서비스 게이트웨이는 클라이언트와 개별 서비스의 호출 사이에 있기 때문에 서비스를 호출하는 중앙 정책 시행 지점(PEP) 역할도 한다. 이 지점을 사용하면 각 개발 팀이 서비스 횡단 관심사를 구현하지 않고 한곳에서 수행할 수 있다. 서비스 게이트웨이에서 구현할 수 있는 횡단 관심사의 예는 다음과 같다.
  - **정적 라우팅(static routing)**: 서비스 게이트웨이는 단일 서비스 URL과 API 경로로 모든 서비스를 호출한다. 모든 서비스에 대해 하나의 서비스 엔드포인트만 알면 되므로 개발이 편해진다.
  - **동적 라우팅(dynamic routing)**: 서비스 게이트웨이는 유입되는 서비스 요청을 검사하고 요청 데이터를 기반으로 서비스 호출자를 위한 지능적 라우팅을 수행할 수 있다. 예를 들어 베타 프로그램에 참여하는 고객의 서비스 호출은 사람들이 사용하는 버전과 다른 버전의 코드가 실행되는 특정 서비스 클러스터로 라우팅된다.  
  - **인증(authentication)과 인가(authorization)**: 모든 서비스 호출이 서비스 게이트웨이로 라우팅되기 때문에 서비스 게이트웨이는 서비스 호출자가 자신의 인증 여부를 확인할 수 있는 적합한 장소다.  
  - **지표 수집(metric collection)과 로깅(logging)**: 서비스 호출이 게이트웨이를 통과하기 때문에 서비스 게이트웨이를 지표와 로그를 수집하는 데 사용할 수 있다. 또한 사용자 요청에 대한 중요한 정보가 있는지 확인하여 균일한 로깅을 보장할 수 있다. 그렇다고 개별 서비스에서 자료를 수집해서는 안 된다는 것은 아니다. 서비스 게이트웨이를 사용하면 서비스 호출 회수 및 응답 시간처럼 많은 기본 지표를 한곳에서 더 잘 수집할 수 있다.

- 초반부에서 유레카를 소개할 때 중앙 집중식 로드 밸런서가 어떻게 서비스의 단일 장애 지점과 병목점이 될 수 있는지 이야기했다. 서비스 게이트웨이도 올바르게 구현되지 않는다면 동일한 위험이 발생할 수 있기 때문에 구현할 때 다음 사항을 염두에 두기 바란다.
  - **로드 밸런서는 서비스 앞에 있을 때 유용하다**: 이 경우 로드 밸런서를 여러 서비스 게이트웨이 인스턴스 앞에 두는 것은 적절한 설계이며, 필요할 때 서비스 게이트웨이 구현체를 확장할 수 있다. 하지만 모든 서비스 인스턴스 앞에 로드 밸런서를 두는 것은 병목점이 될 수 있어 좋은 생각은 아니다.
  - **서비스 게이트웨이를 무상태(stateless)로 작성하라**: 어떤 정보도 서비스 게이트웨이의 메모리에 저장하면 안 된다. 주의하지 않으면 게이트웨이의 확장성을 제한할 수 있다. 따라서 데이터는 모든 서비스 게이트웨이 인스턴스에 복제되어야 한다.
  - **서비스 게이트웨이를 가볍게 유지하라**: 서비스 게이트웨이는 서비스를 호출할 때 ‘병목점’이 될 수 있다. 서비스 게이트웨이에서 여러 데이터베이스를 호출하는 복잡한 코드가 있다면 추적하기 어려운 성능 문제의 원인이 될 수 있다.
- 이제 스프링 클라우드 게이트웨이를 사용하여 서비스 게이트웨이를 구현하는 방법을 살펴보자. 스프링 클라우드 팀에서 선호하는 API 게이트웨이이기 때문에 우리는 스프링 클라우드 게이트웨이를 사용한다.

---

## 스프링 클라우드 게이트웨이 소개

- 스프링 클라우드 게이트웨이는 스프링 프레임워크 6, 프로젝트 리액터(Project Reactor), 스프링 부트 3.0을 기반으로 한 API 게이트웨이 구현체다. 그렇다면 논블로킹은 무슨 뜻일까? 논블로킹 애플리케이션은 주요 스레드를 차단하지 않는 방식으로 작성된다. 따라서 이러한 스레드는 언제나 요청을 받아 백그라운드에서 비동기식으로 처리하고 처리가 완료되면 응답을 반환한다. 스프링 클라우드 게이트웨이는 다음 기능들을 제공한다.
  - **애플리케이션의 모든 서비스 경로를 단일 URL에 매핑한다**: 스프링 클라우드 게이트웨이는 하나의 URL에 제한되지 않고 실제로 여러 경로의 진입점을 정의하고 경로 매핑을 세분화할 수 있다(각 서비스 엔드포인트가 고유한 경로로 매핑된다). 하지만 가장 일반적인 사용 사례라면 모든 서비스 클라이언트 호출이 통과하는 단일 진입점을 제공하는 것이다.
  - **게이트웨이로 유입되는 요청과 응답을 검사하고 조치를 취할 수 있는 필터(filters)를 작성한다**: 이 필터를 사용하면 코드에 정책 시행 지점을 삽입해서 모든 서비스 호출에 다양한 작업을 수행할 수 있다. 즉, 이 필터로 유입되고 유출되는 HTTP 요청 및 응답을 수정할 수 있다. 
  - **요청을 실행하거나 처리하기 전에 해당 요청이 주어진 조건을 충족하는지 확인할 수 있는 서술자(predicates)를 만든다**: 스프링 클라우드 게이트웨이에는 자체 Route Predicate Factories 세트가 포함되어 있다.
- 스프링 클라우드 게이트웨이를 시작하기 위해 다음 사항을 준비
  - 스프링 클라우드 게이트웨이를 위한 스프링 부트 프로젝트를 설정하고 의존성을 적절히 구성한다.
  - 유레카와 통신할 수 있는 게이트웨이를 구성한다.

### 스프링 부트 게이트웨이 프로젝트 설정
- 스프링 부트를 사용하여 스프링 클라우드 게이트웨이(Spring Cloud Gateway) 서비스를 설정한다.
- Spring Initializr(https://start.spring.io/)에서 새로운 프로젝트를 생성해서 시작해 보자.

![image3](https://raw.githubusercontent.com/yonggyo1125/lecture_springcloud/master/6.%20%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%20%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EC%84%9C%EB%B9%84%EC%8A%A4%20%EB%9D%BC%EC%9A%B0%ED%8C%85/images/3.png)

- 다음 추가 의존성을 build.gradle에 추가한다.
> implementation 'org.springframework.cloud:spring-cloud-starter-bootstrap'
>
> build.gradle

```groovy
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.2.0'
	id 'io.spring.dependency-management' version '1.1.4'
}

group = 'org.choongang'
version = '0.0.1-SNAPSHOT'

java {
	sourceCompatibility = '17'
}

repositories {
	mavenCentral()
}

ext {
	set('springCloudVersion', "2023.0.0")
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-actuator'
	implementation 'org.springframework.cloud:spring-cloud-starter-config'
	implementation 'org.springframework.cloud:spring-cloud-starter-gateway-mvc'
	implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'
	implementation 'org.springframework.cloud:spring-cloud-starter-bootstrap'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

dependencyManagement {
	imports {
		mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
	}
}

tasks.named('test') {
	useJUnitPlatform()
}
```

- 다음 단계는 스프링 클라우드 컨피그 서버에서 설정을 조회하는 데 필요한 구성 정보를 src/main/resources/bootstrap.yml 파일에 설정하는 것이다.

> src/main/resources/bootstrap.yml

```yaml

```

---

## 스프링 클라우드 게이트웨이에서 라우팅 구성 

---

## 스프링 클라우드 게이트웨이의 진정한 능력: Predicate와 Filter Factories

---

## 사전 필터 만들기

---

## 서비스에서 상관관계 ID 사용

---

## 상관관계 ID를 수신하는 사후 필터 작성 

